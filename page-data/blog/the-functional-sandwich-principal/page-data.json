{
    "componentChunkName": "component---src-pages-blog-mdx-slug-js",
    "path": "/blog/the-functional-sandwich-principal/",
    "result": {"data":{"mdx":{"frontmatter":{"date":"June 1, 2020","title":"The Functional Sandwich Principal","description":"Start using functional style in your existing code base today, using the “functional sandwich” principle.","hero_image_alt":"Two sandwiches stacked on a black plate with a blurred background","hero_image_credit_link":"https://unsplash.com/photos/mAQZ3X_8_l0","hero_image_credit_text":"Eiliv-Sonas Aceron","hero_image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#181818","images":{"fallback":{"src":"/static/7677fdc1a66b8306f162fac0fb7ab4ae/d8697/eiliv-sonas-aceron-mAQZ3X_8_l0-unsplash.jpg","srcSet":"/static/7677fdc1a66b8306f162fac0fb7ab4ae/0cb03/eiliv-sonas-aceron-mAQZ3X_8_l0-unsplash.jpg 1000w,\n/static/7677fdc1a66b8306f162fac0fb7ab4ae/fda3c/eiliv-sonas-aceron-mAQZ3X_8_l0-unsplash.jpg 2000w,\n/static/7677fdc1a66b8306f162fac0fb7ab4ae/d8697/eiliv-sonas-aceron-mAQZ3X_8_l0-unsplash.jpg 4000w","sizes":"(min-width: 4000px) 4000px, 100vw"},"sources":[{"srcSet":"/static/7677fdc1a66b8306f162fac0fb7ab4ae/b3e07/eiliv-sonas-aceron-mAQZ3X_8_l0-unsplash.webp 1000w,\n/static/7677fdc1a66b8306f162fac0fb7ab4ae/9ed46/eiliv-sonas-aceron-mAQZ3X_8_l0-unsplash.webp 2000w,\n/static/7677fdc1a66b8306f162fac0fb7ab4ae/76f00/eiliv-sonas-aceron-mAQZ3X_8_l0-unsplash.webp 4000w","type":"image/webp","sizes":"(min-width: 4000px) 4000px, 100vw"}]},"width":4000,"height":6000}}}},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"date\": \"2020-06-01\",\n  \"title\": \"The Functional Sandwich Principal\",\n  \"description\": \"Start using functional style in your existing code base today, using the “functional sandwich” principle.\",\n  \"hero_image\": \"./eiliv-sonas-aceron-mAQZ3X_8_l0-unsplash.jpg\",\n  \"hero_image_alt\": \"Two sandwiches stacked on a black plate with a blurred background\",\n  \"hero_image_credit_text\": \"Eiliv-Sonas Aceron\",\n  \"hero_image_credit_link\": \"https://unsplash.com/photos/mAQZ3X_8_l0\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"There\\u2019s one functional programming principle you ought to know, no matter which is your favorite programming paradigm. Surprisingly, it\\u2019s not a super-advanced, abstract, mathematical mischief. Rather, it is the most basic principle of functional programming.\"), mdx(\"p\", null, \"Although simple, it is very powerful and I believe I write better code since I started using it as often as I can.\"), mdx(\"h3\", null, \"How it all begun?\"), mdx(\"p\", null, \"I remember learning redux a few years ago. It was the first time I heard the term \\u201Cpure function\\u201D. I was hooked immediately. It all made perfect sense\\u2026 Composition, immutability, pure functions, it all looked so elegant and just\\u2026right.\"), mdx(\"p\", null, \"I started learning more functional programming principals and tried to use them as much as I could in the code I write for my job. It turned out to be more challenging than I thought, as not all functional techniques are immediately \\u201Creadable\\u201D the first time you encounter them.\"), mdx(\"p\", null, \"In addition, working in a large team, where not everybody is as excited about functional programming as I am, is limiting in that regard.\"), mdx(\"p\", null, \"Having said that, the most basic principle of functional programming is quite easy to implement and can be understood by everybody.\"), mdx(\"p\", null, \"By using a specific structure sometimes called \\u201Cthe functional sandwich\\u201D, we can enjoy its benefits and make our code even more readable.\"), mdx(\"p\", null, \"So let\\u2019s see how to make a functional sandwich.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"The secret sauce \\u2014 pure functions\"), mdx(\"p\", null, \"Pure functions are the fundamental building block of functional programming. They are regular functions, adhering to 3 constraints:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"For the same given input, a pure function will always return the same output.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A pure function depends only on its explicit inputs.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A pure function can never induce side effects.\")), mdx(\"p\", null, \"To better understand, let\\u2019s see a simple example of functions breaking the rules above.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"function dayOfWeek() {\\n  return [\\n    'Monday',\\n    'Tuesday',\\n    'Wednesday',\\n    'Thursday',\\n    'Friday',\\n    'Saturday',\\n    'Sunday'\\n  ][new Date().getDay()];\\n}\\n\\nfunction isLanguageSupported(language) {\\n  return window.navigator.languages.some(l => l === language);\\n}\\n\\nfunction getUserData(userId) {\\n  return usersApi.getById(userId)\\n    .then(userData => appState.userData = userData);\\n}\\n\\nconst appState = {};\\n\\nfunction main() {\\n  appState.dayOfWeek = dayOfWeek();\\n  appState.isEnglishSupported = isLanguageSupported('en');\\n  \\n  const userId = getUserIdFromCookie();\\n  \\n  getUserData(userId);\\n}\\n\\nmain();\\n\")), mdx(\"center\", null, mdx(\"small\", null, \"Code snippet #1 \\u2014 some impure functions\")), mdx(\"p\", null, \"Each of the first 3 functions violates one of the restrictions listed above, making them all impure.\"), mdx(\"p\", null, \"The first function dayOfWeek, will return a different value every day, thus violating the first rule \\u201Calways return the same output for the same given input\\u201D.\"), mdx(\"p\", null, \"The second, isLanguageSupported, depends on the contents of the languages array. This array was initialized outside the scope of the function and was not given to it as an input, thus this function violates the second rule \\u201Cdepend only on explicit inputs\\u201D.\"), mdx(\"p\", null, \"getUserData is the worst offender, violating the third rule not once, but twice! It performs 2 kinds of side effects:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Network call to users API.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Mutation of a global appState variable.\")), mdx(\"p\", null, \"The last function, main, is automatically ruled out since it\\u2019s calling impure functions.\"), mdx(\"p\", null, \"On the other hand, let\\u2019s look at this code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"function getUserName(user) {\\n  return user.name;\\n}\\n\\nfunction splitFullName(fullName) {\\n  const [firstName, ...otherNameParts] = fullName.split(' ');\\n  \\n  return {\\n    firstName,\\n    lastName: otherNameParts.join(' ')\\n  };\\n}\\n\\nfunction getUsersNames(users) {\\n  return users.map(getUserName).map(splitFullName);\\n}\\n\")), mdx(\"center\", null, mdx(\"small\", null, \"Code snippet #2 \\u2014 some pure functions\")), mdx(\"p\", null, \"Every function here is pure, as they all follow the rules above.\"), mdx(\"p\", null, \"It\\u2019s much less verbose, everything is very predictable and very easy to compose as demonstrated by the last function getUsersNames.\"), mdx(\"p\", null, \"Let\\u2019s keep exploring the benefits of using pure functions.\"), mdx(\"h2\", null, \"The benefits of pure functions\"), mdx(\"p\", null, \"What do we gain by writing pure functions? Isn\\u2019t just using side effects and accessing global variables easier and gets the job done anyway?\"), mdx(\"p\", null, \"We mentioned some of the advantages by the end of the last section, but let\\u2019s consider the full list of benefits of writing pure functions:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Pure functions are easier to reason about and debug \\u2014 since pure functions depend only on explicit inputs and never induce side effects, it\\u2019s very easy to isolate them. Once you know you got the logic right, it\\u2019s a done story. When you read them you always have the full context of their execution and never have to juggle other functions/files. Also, impure operations (like network calls and state mutation) do not affect pure functions, so in case of a problem in one of those areas, you can immediately rule out any pure function from the suspects' list.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Pure functions are easier to test \\u2014 since the only dependencies for the function are its explicit inputs, it is easy to isolate and there is almost no need for mocking or more advanced testing techniques.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Pure functions are easier to parallelize \\u2014 two major problems in parallelization are execution order and race conditions. Since pure functions always return the same output, the execution order is not a problem in a parallelized environment. Also the restriction on mutation makes sure we do not accidentally create race conditions by writing to a mutable state.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Pure functions are easier to memoize \\u2014 memoization is a powerful technique for reducing computation time, by avoiding re-computing known values. It works best when the same given inputs always return the same output (otherwise cache eviction and invalidation is needed). Luckily, this is the required behavior for all pure functions.\")), mdx(\"p\", null, \"Considering the above list, suddenly the restrictions on pure functions seem very cost-effective.\"), mdx(\"p\", null, \"So just make all your functions pure and profit, right?\"), mdx(\"h2\", null, \"Those pesky side effects\"), mdx(\"p\", null, \"While this is nice in theory, real-world applications require you to use side effects and keep a mutable state. So what\\u2019s the point in writing pure functions in an impure world?\"), mdx(\"p\", null, \"While side effects are unavoidable, by writing more pure functions, larger parts of our app can enjoy these benefits.\"), mdx(\"p\", null, \"So how do we write more pure functions?\"), mdx(\"p\", null, \"A simple strategy to increase the number of pure functions in our code is splitting it around side effects. Effectively meaning, impure functions will not handle application logic. They will only handle side effects and delegate the real work to a pure function\"), mdx(\"p\", null, \"Let\\u2019s refactor the example from code snippet #1 by splitting it around side effects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"function dayOfWeek(date) {\\n  return [\\n    'Monday',\\n    'Tuesday',\\n    'Wednesday',\\n    'Thursday',\\n    'Friday',\\n    'Saturday',\\n    'Sunday'\\n  ][date.getDay()];\\n}\\n\\nfunction isLanguageSupported(language, languages) {\\n  return languages.some(l => l === language);\\n}\\n\\nfunction updateAppState(userData, date, languages) {\\n  return {\\n    userData,\\n    dayOfWeek: dayOfWeek(date),\\n    isEnglishSupported: isLanguageSupported('en', languages)\\n  };\\n}\\n\\nlet appState = {};\\n\\nasync function main() {\\n  const userId = getUserIdFromCookie();\\n  const userData = await userApi.getById(userId);\\n  \\n  appState = updateAppState(\\n    userData,\\n    new Date(),\\n    window.navigator.languages\\n  );\\n}\\n\\nmain();\\n\")), mdx(\"center\", null, mdx(\"small\", null, \"Code snippet #3 \\u2014 splitting around side effects\")), mdx(\"p\", null, \"We start by moving all the impure parts to the main function, the entry point for our code. We modify functions to accept more inputs where needed, to avoid breaking the second rule (inputs must be explicit).\"), mdx(\"p\", null, \"This means getUserData is not needed anymore, since all it did was fetching data and mutating state. In larger apps we might still split impure code to reduce responsibilities and make our code more readable. In this case it is not necessary.\"), mdx(\"p\", null, \"On the other hand, the composition of the appState can be expressed in a pure manner, so the second thing we did is extract it to a pure function named updateAppState and call it from main.\"), mdx(\"p\", null, \"Now the business logic of our app is broken into small, composable parts, which can be easily tested. Also, the only place mutating the appState is the main function, so it will make our life easier as we know nothing else influence or can be influenced by the global appState.\"), mdx(\"h2\", null, \"The functional sandwich principle\"), mdx(\"p\", null, \"Turns out, avoiding side effects has an interesting side effect (pun intended). It creates a very specific flow in our program.\"), mdx(\"p\", null, \"Pure functions can\\u2019t call impure functions, as it will make them impure. They can of course still call other pure functions, it does not affect their purity what so ever.\"), mdx(\"p\", null, \"On the other hand, impure functions do not benefit by not calling pure functions. Hence impure functions can call both pure and impure functions.\"), mdx(\"p\", null, \"By splitting the code around side effects and creating more pure functions, the code gets structured like a \\u201Cfunctional sandwich\\u201D. Or as some might say, the code has an imperative shell and a functional core.\"), mdx(\"p\", null, \"Pure functions will always be called and eventually return to an impure function. Covered from both sides by an imperative bread, like a tasty functional sandwich.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/0ab09848e54786c60570258ce5d3ef0a/a4c31/a-functional-sandwich.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"55.00000000000001%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABVklEQVQoz42T207CQBCGeVh8Gx4AL+DSGyNGjdFEiIpBEUKAUFqMhyotBwUFNeHQ7u5noEAqh+okk5nZ/Pl3ZvefEDNTSi2i5yCVQspVX8ZO0lk9DOGzOXBWEGR+0rWEc0C/32c8Hk0Rui3QLEHVFlQsLy+/CDpfcrmBVUIhxDTGYnEMXcP8AK3uUHhyMWwXoyG4awoe2oLco8vnIKDDyeGcMBrdRtfKnGpwUna5qCmOy4qUrrh+gMw97GQczDcPLzeNvOgwHqdmVClYcFnqkki3KFSbpIstjjJtkrkmB/kB7b7aTKimv+m9SyQS4TZ7Q9YE0+7RsJt8d1tYVpti1aL3anOlDzE7/yQMh7dI7O1OO0xpDvsFxWFRcaYpzmuQ1CGRd2n1ZPDI/l92nDEjF4yGS+nZ80rdRbO83HqXwTpc0pRfCX/qcK1sfDf93hS5flNkwKb8AEM/TF3LiBUqAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"A functional sandwich\",\n    \"title\": \"A functional sandwich\",\n    \"src\": \"/static/0ab09848e54786c60570258ce5d3ef0a/c1b63/a-functional-sandwich.png\",\n    \"srcSet\": [\"/static/0ab09848e54786c60570258ce5d3ef0a/5a46d/a-functional-sandwich.png 300w\", \"/static/0ab09848e54786c60570258ce5d3ef0a/0a47e/a-functional-sandwich.png 600w\", \"/static/0ab09848e54786c60570258ce5d3ef0a/c1b63/a-functional-sandwich.png 1200w\", \"/static/0ab09848e54786c60570258ce5d3ef0a/d61c2/a-functional-sandwich.png 1800w\", \"/static/0ab09848e54786c60570258ce5d3ef0a/a4c31/a-functional-sandwich.png 2073w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \"), mdx(\"center\", null, mdx(\"small\", null, \"A functional sandwich\"))), mdx(\"p\", null, \"If you keep at it, all the side effects will eventually be pushed to the \\u201Cedges\\u201D of the app. As part of the server\\u2019s API, or listening to a DOM event.\"), mdx(\"p\", null, \"This is good practice, as it makes all the business logic very isolated, easy to test, and to reason about.\"), mdx(\"h2\", null, \"Next steps\"), mdx(\"p\", null, \"Functional programming is amazing! I highly encourage you to learn more about it. Though it might be intimidating at first, it is beautiful, mind-opening and there is quite a lot to learn from it to use in practice.\"), mdx(\"p\", null, \"Recently I also gained more respect and insight towards object-oriented techniques, by researching their relation to functional programming, and how to implement some functional techniques in different languages.\"), mdx(\"p\", null, \"Check these out, as they helped me a lot:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://frontendmasters.com/courses/functional-javascript/\"\n  }, \"https://frontendmasters.com/courses/functional-javascript/\"), \" \\u2014 this is where I first heard the \\u201Cfunctional sandwich\\u201D metaphor, and a very good watch regardless\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell\"\n  }, \"https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell\"), \" \\u2014 a very good example of a more complex program, structured into a functional core with an imperative shell\")), mdx(\"p\", null, \"Bon appetite!\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Thanks to Yonatan Kra for reviewing\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"80d63e27-3bc7-541d-a765-e3e354a1055b","slug":"the-functional-sandwich-principal/","__params":{"slug":"the-functional-sandwich-principal"}}},
    "staticQueryHashes": ["2730095376"]}